# Computation {#ch:computation}

This chapter explains the basic computations needed for fitting and
evaluation the Rasch model. We distinguish the following steps:

* Data preparation (\@ref(sec:datapreparation))
* Estimation of item parameters (\@ref(sec:itemestimation))
* Anchoring (\@ref(sec:anchoring))
* Estimation of the $D$-score (\@ref(sec:dscoreestimation))

Reader not interested in these details may continue to model
evaluation in Chapter \@ref(ch:evaluation).

## Data preparation {#sec:datapreparation}

Data SMOCC data of Secion \@ref(sec:ddi)

## Item parameter estimation {#sec:itemestimation}

There are many computer routines for this task, but only a few produce
the desired result when applied to developmental data.

```{r smoccfit2, echo = FALSE, warning = FALSE}
library(gseddata)
library(dmetric)
data <- get_data(cohorts = 53)
items <- get_itemnames(data)
varlist <- list(adm = c("cohort", "subjid", "agedays"), 
                items = items,
                cov = NULL)
model <- fit_dmodel(varlist, data, name = "57_0")
```


## Anchoring {#sec:anchoring}



## Estimation of the $D$-score {#sec:dscoreestimation}

The $D$-score quantifies development of a child. In order to calculate
the $D$-score we need the following ingredients:

* Child's PASS/FAIL scores on the milestones administered;

* The difficulty estimates of each milestone administered;

* A prior distribution, an estimate of the $D$-score distribution
before seeing any PASS/FAIL score.

Using these inputs, we may use Bayes theorem to calculate the position
of the person on the latent variable. The method is known as the
Expected a posteriori (EAP) estimation, and was first described by
@bock1982.

### EAP algorithm

Calculation of the $D$-score proceeds item by item. Suppose we have
some vague and preliminary idea about the distribution of $D$. The
procedure uses Bayes rule to update this prior knowledge with data
from the first item (fail/pass score, item difficulty) to calculate
the posterior. In the next step, this posterior is used as the prior
for the next item, and so on. The procedure stops when all items have
been used. The order in which items are entered does not matter for
the end result. The $D$-score is equal to the mean of the last
posterior.

### Age-dependent starting prior

In the first step, we need a starting distribution as prior. The
starting prior should define the range of reasonable values for $D$.
For example, an infant aged 1 months the $D$-score will have lower
$D$-score than a child aged 15 months. The prior should be a bit
informative but not too much, so it was decided to choose a broad
distribution which was centred quite well. The prior was chosen as a
normal distribution with a mean equal to the $D$-score expected at the
child's age, and with a standard deviation of 5, which about twice the
normal variation in the $D$-score.

```{r figpriors, echo = FALSE,  fig.cap="\\label{fig:figpriors} Age-dependent starting priors for the D-score at the ages of 1, 15 and 24 months", fig.height = 4}
library(dscore)
library(ggplot2)
#example from the adp function in ggplot:
qp <- -10:80

p1m <- data.frame(qp = qp, month = rep(1, length(qp)), p = adp(1/12, qp))
p15m <- data.frame(qp = qp, month = rep(15, length(qp)), p = adp(15/12, qp))
p24m <- data.frame(qp = qp, month = rep(24, length(qp)), p = adp(24/12, qp))

dataprior <- rbind(p1m, p15m, p24m) %>%
  mutate(month = as.factor(month)) %>%
  dplyr::filter(p > 0.00001)

p <- ggplot(dataprior, aes(qp, p, group = month)) +
  theme_light() + 
  theme(legend.position = c(0.05, 0.95), legend.justification = c(0, 1)) +
  geom_path(aes(colour = month)) +
  coord_cartesian(xlim = c(-10, 80)) +
  scale_y_continuous(name = "Density", limits = c(0, 0.3)) +
  scale_x_continuous(name = "D-score") +
  labs(colour = "Age (in months)") +
  scale_colour_manual(values = brewer.pal(12, "Paired")[c(1, 3, 5)])
p
```

Figure \@ref(fig:figpriors) illustrates starting distributions
(priors) for the ages of 1, 15 and 24 months. As expected, the assumed
ability of an infant aged of 1 month is lower than that of a child
aged 15 months, which in turn is lower than the ability of a toddler
aged 24 months.

### Numerical example

Suppose we measure two boys aged 15 months, David and Rob, by the DDI.
David passes the first four milestones, but does not complete the test.
Rob completes the test, but fails on two out of five milestones. 

```{r datadavidandrob, echo = FALSE}
items <- c("ddifmd011", "ddifmm012", "ddicmm037", "ddigmm066", "ddigmm067")
ib <- model$itembank %>%
  rename(item  = lex_gsed, delta = tau) %>%
  filter(item %in% items) %>%
  dplyr::select(item, label, delta)
dr <- data.frame(ib, 
                  David = c(1, 1, 1, 1, NA),
                  Rob = c(1, 0, 1, 1, 0))
dr <- dr[c(2, 3, 1, 4, 5), ]
kable(dr, caption = "Scores of David and Rob on five milestones from the DDI", 
      row.names = FALSE, col.names = c("Item", "Label", "Delta", "David", "Rob"))
```

Table \@ref(tab:datadavidandrob) shows the difficulties of each
milestone and the responses of David and Rob for the standard five DDI
milestones for the age of 15 months. The mean $D$-score for Dutch
children aged 15 months is 53.6$D$, so the milestones are easy to pass
at this age, with the most difficult being `ddicmm037`. David passed
all milestones, but has no score on the last. Rob fails on `ddifmm012`
and `ddigmm067`. How do we calculate the $D$-score for David and Rob?

```{r davidplot, echo = FALSE, fig.height = 12, fig.cap = '(ref:davidplot)'}
# full posterior 1e item
qp <- -10:80

# David
david <- matrix(NA, nrow = length(qp), ncol = 10, 
                dimnames = list(NULL, c(paste0("prior", 1:5), paste0("post", 1:5))))
it1 <- dscore(c(1, NA, NA, NA, NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
it2 <- dscore(c(1,  1, NA, NA, NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
it3 <- dscore(c(1,  1,  1, NA, NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
it4 <- dscore(c(1,  1,  1,  1, NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
it5 <- dscore(c(1,  1,  1,  1,  NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
david[, "prior1"] <- it1$`1.25`$start
david[, c("post1", "prior2")] <- it1$`1.25`$posterior
david[, c("post2", "prior3")] <- it2$`1.25`$posterior
david[, c("post3", "prior4")] <- it3$`1.25`$posterior
david[, c("post4", "prior5")] <- it4$`1.25`$posterior
david[, "post5"] <- it5$`1.25`$posterior

# Rob
rob <- matrix(NA, nrow = length(qp), ncol = 10, 
                dimnames = list(NULL, c(paste0("prior", 1:5), paste0("post", 1:5))))
it1 <- dscore(c(1, NA, NA, NA, NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
it2 <- dscore(c(1,  0, NA, NA, NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
it3 <- dscore(c(1,  0,  1, NA, NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
it4 <- dscore(c(1,  0,  1,  1, NA), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
it5 <- dscore(c(1,  0,  1,  1,  0), 
              items = items, age = rep(1.25, 5), full = TRUE, 
              itembank = model$itembank, lexicon = "gsed", qp = qp)
rob[, "prior1"] <- it1$`1.25`$start
rob[, c("post1", "prior2")] <- it1$`1.25`$posterior
rob[, c("post2", "prior3")] <- it2$`1.25`$posterior
rob[, c("post3", "prior4")] <- it3$`1.25`$posterior
rob[, c("post4", "prior5")] <- it4$`1.25`$posterior
rob[, "post5"] <- it5$`1.25`$posterior

# create plotting data
plotdata <- expand.grid(x = qp, item = items, 
                        type = c("Prior", "Posterior"), 
                        person = c("David", "Rob"))
plotdata <- cbind(plotdata, y = c(as.vector(david), as.vector(rob)))
plotdata <- plotdata %>%
  dplyr::filter(y > 0.00001)

p <- ggplot(plotdata, aes(x = x, y = y)) +
  theme_light() + 
  theme(legend.position = "bottom") + 
  geom_path(aes(colour = type)) +
  facet_grid(item ~ person) +
  coord_cartesian(xlim = c(40, 70)) +
  scale_y_continuous(name = "Density", limits = c(0, 0.32)) +
  scale_x_continuous(name = "D-score") +
  labs(colour = "Type of distribution") + 
  scale_colour_manual(values = brewer.pal(12, "Paired")[c(3, 4)])
p
```

(ref:davidplot) $D$-score distribution for David and Rob before
(prior) and after (posterior) a milestone is taken into account.

Figure \@ref(fig:davidplot) shows how the prior transforms into the
posterior after the measurement outcomes is fed into the calculation. There 
are five milestones, and so calculation is done in five steps:

1. Both David and Rob pass `ddifmd011`. The prior (lightgreen) is the
same as in Figure \@ref(fig:figpriors). After a PASS, the posterior
will be located more to the right, and will often be more peaked. Both
happen here, but the change is small. The reason is that a PASS on
this milestone is not very informative. For a child with a true
$D$-score of 53$D$, the probability of passing `ddifmd011` is equal to
`r plogis((53 - 46) / model$transform[2])`. If passing is so common,
there is not much information in the measurement.

2. David passes `ddifmm012` but Rob does not. Observe that the prior
is identical to the posterior of `ddifmd011`. For David, the posterior
is only slightly different from the prior, for the same reason as
above. For Rob, we find a huge change to the left, both in terms of
location (from 54.3$D$ to 47.1$D$) and in terms of peakedness. This one 
FAIL lowers Rob's score by 7.2$D$.

3. Milestone `ddicmm037` is more difficult than the previous two
milestones, so a pass on `ddicmm037` does have a clear effect on the
posterior for both David and Rob.

4. David's PASS on `ddigmm066` does not bring any additional
information, so his prior and posterior are virtually
indistinguishable. For Rob, we find a slight effect to the right.

5. There is no measurement for David on `ddigmm067`, so the prior and 
posterior are equivalent. For Rob, we observe a FAIL, which shifts his 
posterior to the left.

The $D$-score is calculated as the mean of the posterior. David's
$D$-score is equal to 55.7$D$. Note that the measurement error, as
estimated from the variance of the posterior, is fairly large. Rob's
$D$-score is equal to 47.7$D$, with a much smaller measurement error.
This result is consistent with the design principles of the DDI, which
is meant to detect children with developmental delay.

The example illustrates that the effects of the measurement on the
$D$-score depend on the match between the true (but unknown) $D$-score
of the child and the difficulty of the milestone.

### Technical observations on $D$-score estimation

* Administration of a very easy set of milestones introduces a
*ceiling* with children that pass all milestones, but whose true
$D$-score could extend well beyond the ceiling. Depending on the goal
of the measurement, this may or may not be a problem.

* The specification of the prior and posterior distributions requires a
set of quadrature points at which their densities are calculated. The
set of quadrature is taken here as the static and evenly-spaced set of
integers between -10 and +80. Using other quadrature points may have a
slight effect on the estimate.

* The actual calculations are here done item by item. A more efficient
method is to handle all responses at once. The end result will be the
same.

