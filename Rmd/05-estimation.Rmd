# Computation {#ch:computation}

This chapter explains the basic computations needed for fitting and
evaluation the Rasch model. We distinguish the following steps:

* Identify nature of the problem (\@ref(sec:datapreparation))
* Estimation of item parameters (\@ref(sec:itemestimation))
* Anchoring (\@ref(sec:anchoring))
* Estimation of the $D$-score (\@ref(sec:dscoreestimation))

Reader not interested in these details may continue to model
evaluation in Chapter \@ref(ch:evaluation).

## Identify nature of the problem {#sec:datapreparation}

The SMOCC dataset, introduced in Section \@ref(sec:smocc), contains
scores on the DDI of Dutch children aged 0-2 years made during nine
visits.

```{r smoccdata2, warning = FALSE}
library(gseddata)
data <- get_data(cohorts = 53)
items <- get_itemnames(data)
broad <- as.data.frame(data) %>% 
  dplyr::select(subjid, agedays, items) %>% 
  dplyr::slice(1:26)
options(knitr.table.format = "html", knitr.kable.NA = "") 
kable(broad,
      caption = "SMOCC DDI milestones, first three children, 0-2 years.",
      row.names = FALSE, 
      col.names = c("Child", "Age (days)", items)) %>%
  kableExtra::kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

Table \@ref(tab:smoccdata2) contains data of three children, measured
on nine visits between ages 0 - 2 years. The DDI scores are coded as 0
(FAIL) or 1 (PASS). Since the selection of milestones depends on age,
the dataset contains a large number of empty cells. Naive use of sum
scores as a proxy to person ability is therefore problematic. An empty
cell is not a FAIL, so it's an error to impute those cells by zeroes.

Note that some rows contain only 1's, e.g., in row 2 or row 10. Many
computer program for Rasch analysis routinely remove such *perfect
scores* before fitting. However, unless the number of perfect scores
is very small, this is not recommended because doing so can severely
affect the distribution of person abilities.

In order to effectively handle the missing data and to preserve all
persons in the analysis we separate estimation of item difficulties
and person abilities into two steps.

## Item parameter estimation {#sec:itemestimation}

```{r smoccfit2, warning = FALSE}
varlist <- list(adm = c("cohort", "subjid", "agedays"), 
                items = items,
                cov = NULL)
model <- dmetric::fit_dmodel(varlist, data, name = "57_0")
```

There are many methods for estimating the difficulty parameters of the
Rasch estimation. See @linacre2004 for an overview. We will use the
pairwise method estimation method (@zwinderman1995), as implemented in
the function `rasch.pairwise.itemcluster()` of the `sirt` package
(@robitzsch2016).

```{r itemdiflplot, fig.height = 10, fig.cap = '(ref:itemdiflplot)'}
d1 <- data.frame(delta = model$fit$b, 
                 item = names(model$fit$b), 
                 stringsAsFactors = FALSE, 
                 row.names = NULL)
ib <- model$itembank %>% 
  rename(item = lex_gsed) %>% 
  left_join(d1, by = "item") %>% 
  mutate(lab = substr(label, 1L, 30)) %>% 
  mutate(domain = plyr::revalue(domain, c("cm" = "Communication", 
                                          "fm" = "Fine motor",
                                          "gm" = "Gross motor")))

p <- ggplot(ib, aes(x = delta, y = reorder(lab, -delta))) + 
  geom_segment(aes(yend = lab), xend = -30, colour = "grey50") +
  geom_point(size = 2, aes(colour = domain)) + 
  theme(panel.grid.major.y = element_blank()) +
  facet_grid(domain ~ ., scales = "free_y", space = "free_y") + 
  theme(legend.position = "none") + 
  xlab("Item difficulty (logits)") +
  theme(axis.title.y = element_blank())
p
```

(ref:itemdiflplot) Estimated item difficulty parameters ($d_i$) for 57 milestones
of the DDI (0 - 2 years).

Figure \@ref(fig:itemdiflplot) summarizes the estimated item
difficulty parameters. Although the model makes no distinction between
domains, the results have been ordered to ease spotting of the natural
progression of the milestones per domain. The figure also suggests
that not all domain are equally represented across the scale. For
example, there are no communication milestones around the logit of
$-10$.

## Anchoring {#sec:anchoring}

The Rasch model identifies the item difficulties up to a linear
transformation. By default, the software produces estimates in the
logit scale (c.f. Figure \@ref(fig:itemdiflplot)). The logit scale is
inconvenient for two reasons:

* The logit scale has negative values. Negative values do not have a
sensible interpretation in child development, and are likely to
introduce errors in practice;

* Both the zero in the logit scale as well as its variance depend on
the sample used to calibrate the item difficulties.

The properties of the Rasch model are preserved under a rescaling of
the derived scale. In order to make the scale independent of the
specified sample, we transform the scale so that two items will always
have the same value on the transformed scale. The choice of the two
anchor items is essentially arbitrary, but they should correspond to
milestones that are easy to measure with small error. In the sequel,
we use the two milestones to anchor the scale:

Value  | Item        | Label
------ | ----------- | ------------------------------------------
20     | `ddigmd057` | Lifts head to 45 degrees on prone position
40     | `ddigmd063` | Sits in stable position without support

This is called the $D$-score scale. 

With this choice, $D$-score values are approximately 0$D$ around
birth. At the age of 1 year, the score will around 50$D$, so during
the first year of life, one $D$ unit corresponds to approximately a
one-week interval.

```{r itemdifdplot, fig.height = 10, fig.cap = '(ref:itemdifdplot)'}
p <- ggplot(ib, aes(x = tau, y = reorder(lab, -delta))) + 
  geom_segment(aes(yend = lab), xend = -30, colour = "grey50") +
  geom_point(size = 2, aes(colour = domain)) + 
  theme(panel.grid.major.y = element_blank()) +
  facet_grid(domain ~ ., scales = "free_y", space = "free_y") + 
  theme(legend.position = "none") + 
  xlab("Item difficulty (D-score)") +
  theme(axis.title.y = element_blank())
p
```

(ref:itemdifdplot) Estimated item difficulty parameters ($d_i$) for 57 milestones
of the DDI (0 - 2 years). Milestones `ddigmd057` and `ddigmd063` are anchored at 
values of 20 and 40, respectively.

## Estimation of the $D$-score {#sec:dscoreestimation}

The $D$-score quantifies development of a child. In order to calculate
the $D$-score we need the following ingredients:

* Child's PASS/FAIL scores on the milestones administered;

* The difficulty estimates of each milestone administered;

* A prior distribution, an estimate of the $D$-score distribution
before seeing any PASS/FAIL score.

Using these inputs, we may use Bayes theorem to calculate the position
of the person on the latent variable. The method is known as the
Expected a posteriori (EAP) estimation, and was first described by
@bock1982.

### EAP algorithm

Calculation of the $D$-score proceeds item by item. Suppose we have
some vague and preliminary idea about the distribution of $D$. The
procedure uses Bayes rule to update this prior knowledge with data
from the first item (fail/pass score, item difficulty) to calculate
the posterior. In the next step, this posterior is used as the prior
for the next item, and so on. The procedure stops when all items have
been used. The order in which items are entered does not matter for
the end result. The $D$-score is equal to the mean of the last
posterior.

### Age-dependent starting prior {#sec:adp}

In the first step, we need a starting distribution as prior. The
starting prior should define the range of reasonable values for $D$.
For example, an infant aged 1 months the $D$-score will have lower
$D$-score than a child aged 15 months. The prior should be a bit
informative but not too much, so it was decided to choose a broad
distribution which was centered quite well. The prior was chosen as a
normal distribution with a mean equal to the $D$-score expected at the
child's age, and with a standard deviation of 5, which about twice the
normal variation in the $D$-score.

```{r figpriors, fig.cap="\\label{fig:figpriors} Age-dependent starting priors for the D-score at the ages of 1, 15 and 24 months", fig.height = 4}
#example from the adp function in ggplot:
qp <- -10:80

p1m <- data.frame(qp = qp, month = rep(1, length(qp)), p = dscore::adp(1/12, qp))
p15m <- data.frame(qp = qp, month = rep(15, length(qp)), p = dscore::adp(15/12, qp))
p24m <- data.frame(qp = qp, month = rep(24, length(qp)), p = dscore::adp(24/12, qp))

dataprior <- rbind(p1m, p15m, p24m) %>%
  mutate(month = as.factor(month)) %>%
  dplyr::filter(p > 0.00001)

p <- ggplot(dataprior, aes(qp, p, group = month)) +
  theme(legend.position = c(0.05, 0.95), legend.justification = c(0, 1)) +
  geom_path(aes(colour = month)) +
  coord_cartesian(xlim = c(-10, 80)) +
  scale_y_continuous(name = "Density", limits = c(0, 0.3)) +
  scale_x_continuous(name = "D-score") +
  labs(colour = "Age (in months)") +
  scale_colour_manual(values = brewer.pal(12, "Paired")[c(1, 3, 5)])
p
```

Figure \@ref(fig:figpriors) illustrates starting distributions
(priors) for the ages of 1, 15 and 24 months. As expected, the assumed
ability of an infant aged of 1 month is lower than that of a child
aged 15 months, which in turn is lower than the ability of a toddler
aged 24 months.

### Numerical example

Suppose we measure two boys aged 15 months, David and Rob, by the DDI.
David passes the first four milestones, but does not complete the test.
Rob completes the test, but fails on two out of five milestones. 

```{r datadavidandrob}
items <- c("ddifmd011", "ddifmm012", "ddicmm037", "ddigmm066", "ddigmm067")
ib <- model$itembank %>%
  rename(item  = lex_gsed, delta = tau) %>%
  filter(item %in% items) %>%
  dplyr::select(item, label, delta)
dr <- data.frame(ib, 
                  David = c(1, 1, 1, 1, NA),
                  Rob = c(1, 0, 1, 1, 0))
dr <- dr[c(2, 3, 1, 4, 5), ]
kable(dr, caption = "Scores of David and Rob on five milestones from the DDI", 
      row.names = FALSE, col.names = c("Item", "Label", "Delta", "David", "Rob"))
```

Table \@ref(tab:datadavidandrob) shows the difficulties of each
milestone and the responses of David and Rob for the standard five DDI
milestones for the age of 15 months. The mean $D$-score for Dutch
children aged 15 months is 53.6$D$, so the milestones are easy to pass
at this age, with the most difficult being `ddicmm037`. David passed
all milestones, but has no score on the last. Rob fails on `ddifmm012`
and `ddigmm067`. How do we calculate the $D$-score for David and Rob?

```{r davidplot, fig.height = 12, fig.cap = '(ref:davidplot)'}
# full posterior 1e item
qp <- -10:80

# David
david <- matrix(NA, nrow = length(qp), ncol = 10, 
                dimnames = list(NULL, c(paste0("prior", 1:5), paste0("post", 1:5))))
it1 <- dscore::dscore(c(1, NA, NA, NA, NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
it2 <- dscore::dscore(c(1,  1, NA, NA, NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
it3 <- dscore::dscore(c(1,  1,  1, NA, NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
it4 <- dscore::dscore(c(1,  1,  1,  1, NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
it5 <- dscore::dscore(c(1,  1,  1,  1,  NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
david[, "prior1"] <- it1$`1.25`$start
david[, c("post1", "prior2")] <- it1$`1.25`$posterior
david[, c("post2", "prior3")] <- it2$`1.25`$posterior
david[, c("post3", "prior4")] <- it3$`1.25`$posterior
david[, c("post4", "prior5")] <- it4$`1.25`$posterior
david[, "post5"] <- it5$`1.25`$posterior

# Rob
rob <- matrix(NA, nrow = length(qp), ncol = 10, 
              dimnames = list(NULL, c(paste0("prior", 1:5), paste0("post", 1:5))))
it1 <- dscore::dscore(c(1, NA, NA, NA, NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
it2 <- dscore::dscore(c(1,  0, NA, NA, NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
it3 <- dscore::dscore(c(1,  0,  1, NA, NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
it4 <- dscore::dscore(c(1,  0,  1,  1, NA), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
it5 <- dscore::dscore(c(1,  0,  1,  1,  0), 
                      items = items, age = rep(1.25, 5), full = TRUE, 
                      itembank = model$itembank, lexicon = "gsed", qp = qp)
rob[, "prior1"] <- it1$`1.25`$start
rob[, c("post1", "prior2")] <- it1$`1.25`$posterior
rob[, c("post2", "prior3")] <- it2$`1.25`$posterior
rob[, c("post3", "prior4")] <- it3$`1.25`$posterior
rob[, c("post4", "prior5")] <- it4$`1.25`$posterior
rob[, "post5"] <- it5$`1.25`$posterior

# create plotting data
plotdata <- expand.grid(x = qp, item = items, 
                        type = c("Prior", "Posterior"), 
                        person = c("David", "Rob"))
plotdata <- cbind(plotdata, y = c(as.vector(david), as.vector(rob)))
plotdata <- plotdata %>%
  dplyr::filter(y > 0.00001)

p <- ggplot(plotdata, aes(x = x, y = y)) +
  theme(legend.position = "bottom") + 
  geom_path(aes(colour = type)) +
  facet_grid(item ~ person) +
  coord_cartesian(xlim = c(40, 70)) +
  scale_y_continuous(name = "Density", limits = c(0, 0.32)) +
  scale_x_continuous(name = "D-score") +
  labs(colour = "Type of distribution") + 
  scale_colour_manual(values = brewer.pal(12, "Paired")[c(3, 4)])
p
```

(ref:davidplot) $D$-score distribution for David and Rob before
(prior) and after (posterior) a milestone is taken into account.

Figure \@ref(fig:davidplot) shows how the prior transforms into the
posterior after the measurement outcomes is fed into the calculation. There 
are five milestones, and so calculation is done in five steps:

1. Both David and Rob pass `ddifmd011`. The prior (light green) is the
same as in Figure \@ref(fig:figpriors). After a PASS, the posterior
will be located more to the right, and will often be more peaked. Both
happen here, but the change is small. The reason is that a PASS on
this milestone is not very informative. For a child with a true
$D$-score of 53$D$, the probability of passing `ddifmd011` is equal to
`r plogis((53 - 46) / model$transform[2])`. If passing is so common,
there is not much information in the measurement.

2. David passes `ddifmm012` but Rob does not. Observe that the prior
is identical to the posterior of `ddifmd011`. For David, the posterior
is only slightly different from the prior, for the same reason as
above. For Rob, we find a huge change to the left, both in terms of
location (from 54.3$D$ to 47.1$D$) and in terms of peakedness. This one 
FAIL lowers Rob's score by 7.2$D$.

3. Milestone `ddicmm037` is more difficult than the previous two
milestones, so a pass on `ddicmm037` does have a clear effect on the
posterior for both David and Rob.

4. David's PASS on `ddigmm066` does not bring any additional
information, so his prior and posterior are virtually
indistinguishable. For Rob, we find a slight effect to the right.

5. There is no measurement for David on `ddigmm067`, so the prior and 
posterior are equivalent. For Rob, we observe a FAIL, which shifts his 
posterior to the left.

The $D$-score is calculated as the mean of the posterior. David's
$D$-score is equal to 55.7$D$. Note that the measurement error, as
estimated from the variance of the posterior, is fairly large. Rob's
$D$-score is equal to 47.7$D$, with a much smaller measurement error.
This result is consistent with the design principles of the DDI, which
is meant to detect children with developmental delay.

The example illustrates that the effects of the measurement on the
$D$-score depend on the match between the true (but unknown) $D$-score
of the child and the difficulty of the milestone.

### Technical observations on $D$-score estimation

* Administration of a very easy set of milestones introduces a
*ceiling* with children that pass all milestones, but whose true
$D$-score could extend well beyond the ceiling. Depending on the goal
of the measurement, this may or may not be a problem.

* The specification of the prior and posterior distributions requires a
set of quadrature points at which their densities are calculated. The
set of quadrature is taken here as the static and evenly-spaced set of
integers between -10 and +80. Using other quadrature points may have a
slight effect on the estimate.

* The actual calculations are here done item by item. A more efficient
method is to handle all responses at once. The end result will be the
same.

