```{r, echo=FALSE}
knitr::opts_chunk$set(error = TRUE)
```

# Outcome {#outcome}

This chapter focusses on the first application of the D-score: the D-score as neurocognitive outcome at 1000 days. In this chapter, we show how the D-score is calculated, demonstrate how to work with the D-score package, and how the D-score can be used as neurocognitive outcome in three different populations. First, the calculations behind the D-score are explained step-by-step and how to do this with the D-score package by means of two example children. Thereafter, the D-scores will be calculated for three different populations at the age of two years: the reference population, population of preterm children, and population of children in LMIC. 

## Application I: D-score as neurocognitive outcome at 1000 days



One of the example children is able to do all items of his/her age, and the other example child is not able to do all items of his/her age. 

*Calculation of the dscore:*

*- hoe start je? (iterative algorithm)*

Uitleg over het van Wiechenschema (zie aanvraag BvLF voor stuk in het Engels).
So for example, for a child of the age of 15 months the van Wiechenschema consists of six items. For each of these six items it is noted whether the child was able to perform this item. An example can be found in the table below, in which *child 1* was able to perform all items and *child 2* was able to perform four of the six items. Based on these scores we can calculate the dscore for both these children.
```{r, echo=FALSE}
child1 <- c(15/12, 1, 1, 1, 1, 1, 1)
child2 <- c(15/12, 1, 0, 1, 1, 1, 0)
tableWS <- rbind(child1, child2)
colnames(tableWS) <- c("age in years", "item 1", "item 2", "item 3", "item 4", "item 5", "item 6")
rownames(tableWS) <- c("child 1", "child 2" )
#item2 : speelt geven/nemen
#item6 : loopt langs
```

```{r, echo=FALSE}
library(knitr)
kable(tableWS, caption = "Example of Van Wiechenschema at the age of 15 months")
```

Calculation of the dscore is an iterative procedure, in which in each step information of one item is added. The iterative procedure uses Bayes rule to update prior knowledge with data to calculate a posterior. In the next step, this posterior is used as the prior and information from a new item is added, leading to a new posterior. When all items have been added, the dscore is equal to the mean of the final posterior distribution. 

*- start verdeling (prior): ability persoon (vrij brede prior verdeling, veel onzekerheid, maar goed gecentreerd)*

In the first step, the score of the first item is combined with the prior. However, at this point we do not have prior knowledge about the child. Hence, we need a distribution to start with as prior. As start distribution it was decided to choose a quite broad distribution which was centred quite well. 
*uitleg over de keuze van de prior nog stuk uitbreiden!!! --> plafond prior (kunnen alle items), 2x de spreidng vd dscore*

The start distributions (priors) at the ages of 1, 15 and 24 months is given in the figure below. This figure shows that the priors assume that ability of a child of the age of 1 month is lower than the ability of a child of the age of 15 months, which in turn is lower than the ability of a child of the age of 24 months. 

```{r, echo = FALSE}
library(dscore)
#example from the adp function:
qp <- -10:80
plot(x = qp, y= adp(1/12, qp), type = "l", 
  main = "Priors at ages of 1, 15 and 24 months", 
  ylab = "Density", xlab = "D-score")
lines(x = qp, adp(1.25, qp), lty = 2)
lines(x = qp, adp(2, qp), lty = 3)
```

*- 1e item, gebruik je Bayes rule om de posterior te berekenen*

First, it is important that the names of the items used are similar to the names of the items in the built-in item bank. In this example we will use the lexicon gcdg. Moreover, the data should be in long format with the following columnnames: items, scores and ages. This leads to the following table:
```{r, echo=FALSE}
WS1_1 <- c("n32", 1, 15/12)
WS1_2 <- c("n33", 1, 15/12)
WS1_3 <- c("v38", 1, 15/12)
WS1_4 <- c("n37", 1, 15/12)
WS1_5 <- c("n34", 1, 15/12)
WS1_6 <- c("n35", 1, 15/12)
tableWS1 <- as.data.frame(rbind(WS1_1, WS1_2, WS1_3, WS1_4, WS1_5, WS1_6), row.names = NULL)
colnames(tableWS1) <- c("items", "scores", "ages")
                        
kable(tableWS1, caption = "Example of Van Wiechenschema at the age of 15 months for 1 child", row.names = NA)
```

In the first step of the iterative procedure, the age-dependent prior is combined with the score of the first item *n34* to define the posterior. In the figure below, you can see that the posterior is smaller than the prior indicating more precision.

*- Laat met een plaatje zien hoe de prior en de posterior zich van elkaar verhouden.*

```{r, echo=FALSE}
scores1 <- tableWS1
items <- c("n34")
age <- 1.25
  
#full posterior 1e item
fp <- dscore(1, items, age, full = TRUE, lexicon = "gcdg")
plot(fp[[1]]$qp, fp[[1]]$posterior, type = "l",
xlab = "D-score", ylab = "Density", 
main = "Age 15 months: 1 PASS at n34")
lines(fp[[1]]$qp, fp[[1]]$start, lty = 2)

```

*- 2e item, gebruik de posterior vd vorige stap als prior en de gegevens van de 2e item om opnieuw de posterior uit te rekenen.*

Now, we can use this posterior distribution as prior when we add another item, e.g. *n35*. If the child, like *child 1*, has a pass on this item the new posterior distribution will look as follows:
```{r, echo=FALSE}
items <- c("n34", "n35")
age <- rep(1.25, length(items))
  
#full posterior 2e item
fp2 <- dscore(c(1,1), items, age, full = TRUE, lexicon = "gcdg")
plot(fp[[1]]$qp, fp2[[1]]$posterior, type = "l",
xlab = "D-score", ylab = "Density", 
main = "Age 15 months: PASS at n34 and n35", col = "red")
lines(fp[[1]]$qp, fp[[1]]$posterior, lty = 2)

```

This plot shows that getting a pass on this item, *n35*, does not give more information (and precision) on the dscore. However, if a child, like *child 2*, had a fail on this item it has a great impact on the posterior. As you can see in the figure below, the posterior is on the left of the prior and has an high precision in comparison to the prior. 

*- laat ook weer zien hoe deze zich van elkaar verhouden.*

```{r, echo=FALSE}
items <- c("n34", "n35")
age <- rep(1.25, length(items))
  
#full posterior 2e item FAIL
fp2 <- dscore(c(1,0), items, age, full = TRUE, lexicon = "gcdg")
plot(fp[[1]]$qp, fp2[[1]]$posterior, type = "l",
xlab = "D-score", ylab = "Density", 
main = "Age 15 months: PASS at n34 and FAIL at n35", col = "blue")
lines(fp[[1]]$qp, fp[[1]]$posterior, lty = 2)

```
Hence, a fail on item *n35* is more indicative than a pass on item *n35* and this is reflected in the posterior distribution of the dscore. 

*- etc. voor alle items.*

In the next four in the iterative procedure, information from the other four items (*n32*, *n33*, *v38* and *n37*) can be added in a similar fashion. The dscore for *child 1* and *child 2* are equal to 55.75 and 47.76, respectively.

```{r, echo=FALSE}
items <- c("n32", "n33", "v38", "n37","n34", "n35")
age <- rep(1.25, length(items))
  
#full posterior for both children and prior
fp6_1 <- dscore(c(1,1,1,1,1,1), items, age, full = TRUE, lexicon = "gcdg")
fp6_2 <- dscore(c(1,0,1,1,1,0), items, age, full = TRUE, lexicon = "gcdg")
plot(fp[[1]]$qp, fp6_2[[1]]$posterior, type = "l",
xlab = "D-score", ylab = "Density", 
main = "Age 15 months: D-scores for child 1 and child 2", col="blue")
lines(fp[[1]]$qp, fp[[1]]$start, lty = 2)
lines(fp[[1]]$qp, fp6_1[[1]]$posterior, col = "red")

```

```{r}
#Dscore child1
dscore(c(1,1,1,1,1,1), items, age, full = FALSE, lexicon = "gcdg") #55.75
#Dscore child2
dscore(c(1,0,1,1,1,0), items, age, full = FALSE, lexicon = "gcdg") #47.76
```


*Note: met deze methode is het mogelijk om scores voor extremen te berekenen, andere methodes (zoals de worms estimator) kunnen dit niet altijd.*

*Prior die gekozen was: plafond prior (wanneer je alle items kan)*




## D-score of reference children at 2 years (MG)


```{r, echo=FALSE}
#Script van Stef:
library("ddata")
library("dscore")
library("dmetric")
studies <- c("Netherlands 1", "Netherlands 2")
data <- get_gcdg(study = studies, min_cat = 10, adm = TRUE, cov = TRUE)
items <- intersect(item_names(study = studies), names(data))
nlbank <- dscore::itembank
d_dutch <- calculate_dscore(data = data, items = items, 
                            itembank = nlbank, lexicon = "gcdg")
ref <- dscore::gcdg_reference
d_dutch$daz <- with(d_dutch, dscore::daz(d = d, x = age / 12, ref = ref))
n_items <- data.frame(id = data$id, age = data$age,
                      n = rowSums(!is.na(data[, items])))
d_dutch <- dplyr::left_join(d_dutch, n_items, by = c("id", "age"))
with(d_dutch, (plot(age, d, cex = 0.6)))
with(d_dutch, (plot(age, daz, cex = 0.6)))
write.table(x = d_dutch, file = "notes/dutch_native.txt",
            sep = "\t", na = "", row.names = FALSE, quote = FALSE)

```


## D-score of pre-terms at 2 years (PD)

## D-score of children in LMIC at 2 years (RO)

## Comparison
